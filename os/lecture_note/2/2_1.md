# 프로세스 관리


## 2.1 프로세스

### 프로세스 vs 프로그램

- 프로세스(process): 실행 중에 있는 프로그램(program in execution)
	- task, job
	- 프로그램이 하드 디스크에서 메인 메모리로 올라온 상황
	- '살아 움직이는' 프로세스
		- pc(program counter), sp(stack pointer), register 값이 바뀌고   
 code(text)/data/stack 영역이 메인 메모리에 생성

- 프로그램: 하드 디스크에 있는 상태(~~ '죽은 듯이 무덤 안에 있는' 상태)   
		-> 아무 일도 못함!

<div style="stle:bold; color: red;">송지원 06:51 부터 다시 정리</div>


### 프로세스 상태

프로세스는 여려가지 상태가 있음

- new 
메인 메모리에 올라옴.
모든 초기화를 끝내면, 실제 실행할 준비가 끝난 상태가 되면 레디

- ready

- running
실제 프로세스가 실행하고 있는 상태

- waiting
IO 만난 상홤
ex 프린트
IO 같은 작업 하면, 해당 프로세스 waiting 상태로 변경시키고
다른 프로세스로 넘어간다

waiting이 끝나면(IO) 다시 ready로 돌가암

- terminated




- 타임 쉐어링 시스템이면 러닝에서 다시 레디로 가는 방법이 있다(time expired)   
자신에게 할당된 시간이 끝나버렸다


프로세스가 끝난 상태

### PCB: Process Control Block

- proecs, 

프로세스에 대한 다양한 정보가 들어있다

하나의 프로세스에 하나의 피씨비가 존재(프로세스 하나마다, 피씨비 하나가 할당)

프로세스 정보
- 어떤 상태에 있는가? (상태 정보)
- PC(프로그램 카운터)- 번지 정보
- 다른 레지스터에 대한 정보

피씨랑 다른 레지스터 정보가 왜 필요한가?    
-> 다시 해당 프로세스로 돌아왔을때, 그때당시의 피씨와 레지스터... 복구하기 위해

- MMU 정보(베이스 값, 리미트 값이 어떤지?)
- CPU 얼마나 사용했는가 -> 너무 한놈만 독점적으로 쓰지 않게끔
- pid : 프로세스 아이디
- list of open files : 해당 응용프로그램에서 어떤 파일들을 사용하고 있는가?
- ...

PCB는 오에스 안의 프로세스 관리 부서 안에 있다!

PCB ~~ 주민등록 정보
-> 사생활 침해할 수도 있는데 왜 가지고 있냐?
=> 정부는 관리하는 애이기 때문에 모든 정보를 가지고 있어야 함!


### 프로세스 대기열(Queue)
줄이라는 뜻

프로세스도 줄을 자주 섬

모든 프로그램은 하드디스크 안에 있다
-> 메인 메모리는 작고, 올라올라는 프로그램은 많다
=> 줄 서서 기다려

하드 디스크 안에 수 많은 잡이 있는데
메인 메모리는 좁다
그래서 메인 메모리를 올라올 때는 잡 큐를 통해서 올라가야 한다

시피유의 서비스를 받으려면 줄 서서 기다려야 함
-> 시간이 경과하면 쫓겨나

IO 사용하려면 또 줄서서 기다려야 함
-> 디바이스 큐



메인 메모리에 올라왔더라도, 씨피유를 받으러ㅕ먼 또 기다려야 함
=> 레디 큐


하나의 프로세스가 태어나서 죽을때까지 



줄 선 프로세스 중에 어떤 놈을 메인 메모리에 올려줄 것 인가?
=> 그것을 결정해주는 것을 잡 스케쥴링이라고 함
잡 스케쥴러 프로그램

잡 스케쥴러 프로그램은 OS안의 프로세스 관리 부서 안에 있음

메인 메모리 안에 기다리고 있는 프로세스가 많음
-> 하나가 끝났을때 다음에 어떤 걸 실행해야 할까?
줄 서서 기다리는 중에 어떤 걸 골라서 서비스 해줄까?
=> 씨피유 스케줄려

디스크 스케쥴러





- Job Queue
	- job scheduler
	- long term scheduler(스케줄링이 일어나는 주기가 길다)

- Ready Queue
	- CPU scheduler
	- short term scheduler (스케줄링이 일어나는 주기가 짧다)
	-> 스위칭이 굉장히 빠르게 일어나기 때문에 동시에 여러 프로그램이 돌아가고 있다고 생각
	-> 제일 중요한 스케줄링 (왜냐하면 제일 중요한 게 CPU 니깐)

- Device Queue
	- device scheduler

 
### Multiprogrmming

- degree of multiprogramming : 멀티 프로그래밍의 정도
=> 메인 메모리에 몇개의 프로세스가 올라가 있는가?

- IO 바운드 프로세스
io 관련 작업을 주로 하는 프로세스
ex) 워드 프로세스.

- CPU 바운드 프로세스
계산 작업을 주로 하는 프로세스
ex) 슈퍼컴퓨터 사용하는 프로그램 - 일기예보


가장 베스트의 케이스는 둘다 적절히 섞여서 사용되는게 좋다
-> 잡 스케쥴러가 적절히 믹스해서 올려줘야 함!
-> 너무 아이오만 하고 씨피유가 놀거나 너무 씨피유만 하고 아이오는 노는 상황은 피해야 함

### Medium-term scheduler

Ex) time sharing system 같은 걸
시간 쪼개서 각 프로세스 한테 균등하게 나눠주는 거

서버 컴퓨터에 여러 사람이 사용하고 있는데,
그럼 메인 메모리에 os, A, B, C의 프로그램이 올라가 있다
-> B라는 사람이 작업하다가 커피타임감
-> CPU는 B의 일을 안함
=> OS의 중요한 역할 중 하나는 성능 향상인데 이게 너무 아까운 거임
=> OS가 B가 받은 메인 메모리를 다시 회수하여 하드디스크에 넣어 놈
비어있는 메인 메모리에 다른 프로세스를 올리거나 다른 A, C한테 더 할당할 수 있음

- swap out
메인 메모리에 있는 걸 디스크로 보내버리는 것

- swap device

- swap in
하드 디스크에 있던 걸 다시 메인 메모리로 올리는 것
이전에 있던 위치와 다를 수 있음

통칭해서 swapping이라고 부름


어떤 놈을 swap device로 보내버릴까 정하는게, medium term scheduler라고 함























