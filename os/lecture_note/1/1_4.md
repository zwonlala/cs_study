
# 이중모드

컴퓨터에 
- 프로세서
- 메인 메모리
- 보조 기억장치
이렇게 구성되어 있고, 

맨 처음 파워를 키면, 메인 메모리에 오에스가 올라가고(부팅) => 이제 오에스가 컴퓨터에 대한 모든 권한을 가지게 된것


[동심원 그림]
-> 어플리케이션에서 하드웨어에 접근하기위해서는 오에스를 거쳐서 접근/요청해야 함



**이중모드**
- 한 컴퓨터를 동시에 여러 사람(프로그램)이 사용하는 환경
- => 어떤 한 사람(프로그램)의 실수/고의로 컴퓨터가 다운되면, 다른 사람들은 피해를 봄
- => 이걸 어떻게 막을까...?

Ex 다운되는 명령어 목록
- STOP: CPU 중지
- HALT
- RESET


∴ 사용자 프로그램은 치명적인 명령어(STOP, ...)를 사용하지 못하게 하자!
=> 오직 관리자만 해당 명령어 낼 수 있음
=> "이중 모드"의 개념이 나옴


"이중 모드(dual mode)"란

시피유가 동작하는 모드를 두가지를 놓겠다는 것 임
- 사용자 모드: 사용자 프로그램 명령어 실행할 시
- 관리자(OS) 모드: OS에 있는 명령어 실행할 시

- 관리자 모드(supervisor mode)
- 시스템 모드(system mode)
- 모니터 모드(monitor mode)
- 특권 모드(privilliged mode)
라고 부르기도 함


**특권 명령 (privilleged instructions)**  
: 유저모드에서는 내릴 수 없고, 관리자 모드에서만 내릴 수 있는 명령
- ldr??? 이것도 맞나? 메모리에 있는 데이터를 레지스터로 가지고 오는 명령
- STOP : 씨피유를 중지
- HALT : 
- RESET : 전체 시스템 초기화
- SET_TIMER : 시간을 설정
- SET_HW : 하드웨어 값을 바꾸는 명령



## 그럼 구체적으로 이중모드는 어떻게 만드는가?

CPU 안에는
- 레지스터
- ALU(계산)
- CU(제어 유닛, Control Unit)
이렇게 되어 있는데

레지스터는 비트들을 모아 둔 것.
그 비트들에 CPU의 상태를 나타내는 정보를 나타낼 수 있다(0 / 1
- 연산의 결과가 0이 됨
- carry
- 오버 플로
...
이런 걸 바로 플래그라고 한다


그리고 플래그 중에
모니터 비트, 시스템 비트 즉 ~~를 나타내는 비트를 추가하는 것.

즉, 모니터 비트가 1이면 시스템 모드이고,
모니터 비트가 0이면 유저 모드임

오에스가 동작할때에는 시스템 모드에서 동작
즉, 모니터 비트가 1이고 모든 명령을 내릴 수 있다

오에스가 동작한 다음 유저 프로그램을 실행할 때는
오에스가 모니터 비트를 0으로 바꿔준다.
그래서 유저 프로그램은 유저모드에서 실행이 되는 것

정리하면,
오에스 서비스 실행될 때는 관리자 모드
~> 유저 프로그램 실행될 때는 사용자 모드
~> HW/SW 인터럽트 발생하면 관리자 모드
~> ISR이 끝나고 나면 다시 사용자 모드



만약 유저 프로그램에서 특권명령을 사용하면,
오에스는 레지스터에 있는 모니터 비트를 확인하여 잘못된 명령임을 확인 한 다음
내부적으로 인터럽트가 발생하였다고 생각하고
오에스 내부에 있는 잘못된 명령을 내렸을때 실행되는 ISR을 실행하여
잘못된 유저 프로그램을 강제 종료함


요즘 거의 대부분의 OS는 이중모드를 지원.


이중 모드는 또 보호와 관련이 있음


# 하드웨어 보호

## - 입출력 장치 보호 (Input/Output device protection)
- 사용자의 잘못된 입출력 명령
Ex) 어떤 사용자가 프린터를 사용하고 있는데, 다른 사람이 RESET 명령이나 출력하려고 함(프린터 혼선)
Ex) 하드 디스크의 다른 사람(유저 프로그램)의 파일을 읽고 쓰려고 함

그래서 오에스에는 입출력 장치를 제어하는 명령이 있는데 바로,

in, out 이다.


in - 입력 장치로부터 정보를 받아드리는 명령  
out - 출력 장치에 명령을 내보내는 명령

아무 프로그램이나 in, out 명령을 내리지 못하게 하려면 => in, out 명령을 특권 명령으로 설정하면 된다!

유저 프로그램에서 입출력 장치를 사용하려고 하려면, 오에스에게 부탁을 한다(S/W 인터럽트 == INT 명령을 내린다)
그럼 INT명령을 처리하는 ISR을 실행시킨다


하드 디스크에 저장되어 있는 값을 불러오기 위해서는 
마찬가지로 오에스의 도움을 받아야 함

그때 만약 사용자 A가 사용자 B의 파일을 요청한다면,
오에스에서는 잘못된 접근이므로 A의 접근을 거절함.
그리고 해당 거절하는 부분은 ISR 앞 부분에 있음


- Privilleged Instruction Violation
사용자 명령이 입출력 명령을 직접 내린 경우, 
유저 모드에서 특권 명령을 실행했으므로 ISR으로 이동하여 서비스를 종료시킴
=> 이걸 Privilleged Instruction Violation(특권 명령을 침범했다)라고 함
=> 오에스는 해당 유저 프로그램을 강제 종료시킴


하드웨어와 일반 유저 프로그램 사이에는 오에스가 가로막고 있음  
-> 일반 유저 프로그램이 하드웨어에 직접적으로 접근을 못함  
-> 하드웨어에 접근하려면 오에스에 부탁( 인터럽트 발생) 해야함   
-> 오에스의 ISR이 동작하면서, 해당 요청을 처리함  
그리고 그 해당 ISR 초기에 해당 요청이 정당한가 판단하는 부분이 있어,  
- 정당하면 해당 요청을 처리
- 정당하지 않으면 해당 요청을 거부   
Ex 다른 사람(응용 프로그램)의 파일을 읽으려고 함   

=> 이렇게 항상 오에스가 중간에서 일을 해준다  

이렇게 하기 위해 입출력 관련 명령을 특권명령으로 두고, 오직 오에스만 해당 명령을 실행할 수 있게 하는 것~~~


## - 메모리 보호 (Memory protection)

최신의 오에스?? 컴퓨터??는, CPU와 메인 메모리가 있는데

메인 메모리에는 오에스가 항상 상주하고 있고  
여러개의 유저 프로그램이 올라가 있다   
(∵ 멀티 프로그래밍 시스템, 시분할 시스템 ~> 동시에 여러 프로그램이 돌고 있다)   

그래서 어떤 유저 프로그램이 실행되면서,
- 다른 유저 프로그램의 메모리
- 오에스 영역의 메모리
에 접근 or 수정할 수 있다(우연, 고의 => OS의 경우 이게바로 '해킹')


### 해결방안 1.Address bus를 지워버리자

cpu에서 메인 메모리로 address bus(몇 번지를 읽겠다고 하는 전기줄 다발)가 감  
-> 그럼 그 몇 번지의 해당하는 데이터가 data bus를 통해서 cpu로 전달

그럼 일반 유저 프로그램이 다른 유저 프로그램의 메모리나 오에스의 메모리에 접근하지 못하게 하려면   
=> Address bus를 지워버리면 됨
=> 그런데 잘라버리면 자신의 address 영역에도 못 들어감 ㅠ
∴ 해결 방안이 아님~

### 해결방안 2.Address bus에 문지기를 두자

address bus 부분에 문지기를 둔 다음,   
유저 프로그램이 돌 때
- 유저 프로그램에게 할당된 범위 안에 있는 address를 CPU가 요청하면 문지기가 통과
- 만약 벗어난 범위의 address를 요청하면 문지기가 거절

그 문지기의 이름은 MMU(Memory ManageMent Unit)이고

MMU를 만드는 방법은   
MMU 안에 두 레지스터를 둔다   
- base
- limit

<div style="stle:bold; color: red;">송지원 46:57 부터 다시 정리하기~</div>


## - CPU 보호 (CPU protection)

