# 전통적 동기화 문제 (Classical Synchronization Problems)

(1) Producer and Consumer Problem
- 생산자-소비자 문제
- 유한버퍼 문제 (Bounded Buffer Problem)   

(2) Readers-Writers Problem - 공유 데이터베이스 접근

(3) Dining Philosopher Problem - 식사하는 철학자 문제



## (2) Readers-Writers Problem - 공유 데이터베이스 접근

공통된 디비에 접근
공통적으로 사용하니깐, 크리티컬 섹션으로 해야 할 듯

- 리더 프로세스
- 라이터 프로세스(읽기 + 모디파이도 하는 프로세스)

디비 접근 자체를 크리티컬 ~ 로 해놓는다

~를 위해

-> 이렇게 하면 비효율적

ex) 리더 프로세스 1개, 라이터 프로ㅔ스 1
-> 가능함!


리더가 들어오면, 다른 리더가 들어오는 것도 가능하게 하는 것

라이터 두개면, 막아야 함~





- The first R/W problem (readers-preference)
- The second R/W problem (writers-preference)
- The Third R/W problem
이거였음~


리더가 들어왔는데, 다른 라이터가 들어오려면 블록

라이터가 들어왔는데, 다른 리더는 블록

리더 두개는 ㅇㅋ



# 3.6 식사하는 철학자 문제 (Dining Philosopher Problem)

이런 상황을 가정

5명의 철학자와 5개의 젓가락

원형 테이블, 5명의 철학자 사이에 젓가락 있음(1개씩)

생각하다 보니, 배가고파 밥을 먹어야 함. 밥을 먹으려면 젓가락이 2개 필요~

생각 -> 식사 -> 생각 -> 식사 -> ...


철학자들에게 번호를 붙임
젓가락엗도 번호를 붙임

0번 철학자가 0번 젓가락을 들면,
4번 철학자는 0번 젓가락을 못 든다!

젓가락은 세마포아로 하면 될 것
(초기값은 1로!)

5명의 철학자를 쓰레드로,
젓가락을 각각을 세마포어로

무한 루프를 돎



자바 코드~

코드를 실행시키니 돌다가 멈춤

이유? : 동기화 문제

코드를 보니, 무한루프를 도는데 갑자기 왜 멈출까?

이유가 바로
잘못된 결과 : starvation : 모든 철학자가 식사를 하지 못해 굶어죽는 상황

이유 : 교착상태

모든 철학자가 배고파서 왼쪽 젓가각을 동시에 들었다.
-> 아무도 식사를 못함
-> 이런 오류를 deadlock(교착상태)라고 함!!!

동기화 문제를 이야기 하다가, 

프로세스 


운영체제에서 가장 중요한게 프ㄹ세스 관리인데,

그중에 중요한게 

효율성 증대시키는 것

잘못하다 보면 deadlock에 걸린!
-> 이걸 처리해야 함!






어떤 자원을 갖고 있으나 다른 자원을 기다리고 있을때,


어떤 자원을 가지고 있으면서 대기하고 있을때~~



- 교착상태 필요조건

- Mutual exclusion (상호 배타)	
	- 철학자 문자에서 젓가락이 상호 배타적
- Hold and Wait (보유 및 대기)
	- ex) 왼쪽 젓가락 잡고 있으면서 오른쪽 젓가락 기다리고있는 상황
- No Preemption (비선점)
	- 젓라각 뺏을 수 없음
- Circular (환형 대기)
	- 원을 이루지 않았다면 교착상태가 일어나지 않았음

위 조건을 모두 만족하면 교착상태가 일어날 수도 있음~

오에스에서는 데드락이 일어나지 않도록 해야함!



- 자원
 요청 (request) → 사용 (use) → 반납 (release)
위와 같은 절차를 통해 자원을 받아야 함!

- 동일 자원

동일타입의 자원이 여러개 있으면 인스턴스라고 함


- 자원 할당도(Resource Allocation Graph)

어떤 자원이 어떤 프로세스에 할당 되었는지


~~를 그림으로 나타낸 것


프로세스 : 원
자원 : 사각형
할당 : 화살표
점 : 인스턴스 갯수






ex) 식사하는 철학자 문제를 자원할당도로 만든다면



