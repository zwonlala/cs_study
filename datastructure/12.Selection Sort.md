

# Selection Sort Pseudocode

개념 : 서로 인접한 두 원소를 비교하여, 크기가 순서대로 되어있지 않으면 정렬하는 알고리즘
 
```js
function SelectionSort(arr) {
  const swap = (arr, i, j) => {
    [arr[i], arr[j]] = [arr[j], arr[i]];
  };

  for (let i=0; i<arr.length; i++) {
    let minValIdx = i;

    for (let j=i+1; j<arr.length; j++) {
      if (arr[j] < arr[minValIdx]) {
        minValIdx = j;
      }
    }

    swap(arr, i, minValIdx);
  }
  return arr;
}

console.log(SelectionSort([2, 5, 4, 1, 3]));
}
```

<br> 
<br> 


송지원 여기서부터....

## 강의 예제 코드

![스크린샷 2022-02-08 오후 10 42 11](https://user-images.githubusercontent.com/13375734/152999145-8c2f90ef-4bbd-4b14-85c6-550d72596c44.jpg)

#### 개선해야 할 점
- 변수명을 minValIdx 보다는 lowest 가 더 적절한 것 같다
- swap 함수를 항상 호출하는 것이 아닌, i와 minValIdx 값이 다를때만 swap 함수를 호출하자


<br> 
<br> 


## 버블 정렬의 시간 복잡도

![bubble time complexity2](https://user-images.githubusercontent.com/13375734/152807836-9c595868-a4a6-4b3a-8f27-8d6dc0032c81.png)

> 설명

- **`버블 정렬`**;    
Best, Avg, Worst 상관없이 모두 이중포문을 N회 반복하고,    
이미 정렬되어 있는 부분이라 교환이 일어나지 않아도 비교는 진행하기 때문에  
모든 케이스 모두 `O(N^2)`

- **`optimized 버블 정렬`**;    
Best 케이스의 경우 첫 outer 포문을 돌 때 N회 반복하고,    
그 후 정렬이 완료되어 있음을 인지하고 종료하기 때문에 Best 케이스는 `O(N)`  
Avg 케이스는 그때그때 달라요   
Worst 케이스는 전부 다 돌아야 하므로 optimized 된 것과 상관없이 `O(N^2)`
