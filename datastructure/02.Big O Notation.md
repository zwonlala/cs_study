알고리즘 강의

# Section 2> 빅오 표기법

## 빅오 표기법이 필요한 이유?

어떤 알고리즘이 더 효율적인지 일아내는 방법
코드를 일반화하고 코드에 대해 말해주고 코드의 상대적 성과를 비교하는 것

이게 무엇인지?

필요한 이유? 돌아가기면 하면 되는 거 아냐?

성능이 중요한 경우,
내놓은 코드가 정상 동작을 한다고 하더라도, 최고의 성능을 내는 코드인지 알 수 있어야 함

코드 버그를 수정하려고 할때, 빅오 표기법은 문제점 뿐 아니라 처리 속도를 늦추는 요소를 이해하는데 도움을 줌



그럼 그냥 코드를 실행하는 시간을 재면 되는 거 아냐?
- 동일한 코드라도 머신이 다르다면 다른 소요시간이 측정됨
- 또 동일한 머신이라도 동일한 코드에 대해 소요시간이 동일하진 않음(조금씩 변화있음)
- 만약 엄청 빠른 알고리즘을 비교하는 상황에 각 알고리즘이 너무 빨리 진행되어 시간 측정을 제대로 할 수 없는 경우가 있을 수도 있다
=> 실제로 실행하면서 코드의 실행 시간을 재지 않고 어떤 코드가 더 나은지, 코드를 실행하지 않고 코드를 비교하기 위한 일반 적인 비교 방법
=> 빅오 표기법



그럼 코드의 실행시간을 측정하는 방법은 문제가 있으니,
“컴퓨터가 실행해야하는 단순 동작의 수를 세 보자!!!”
-> 머신의 성능이나 종류와 상관없이 항상 동일한 값을 나타냄!

우리의 목적은 전반적인 추세를 알기 원하는 것이므로 정확한 실행 횟수 계산이 필요하진 않음(…?)


# 빅오
빅오는 “애매한 측량을 정형화한 방법”
알고리즘의 입력값이 커짐에 따라 실행 시간이 늘어나는 정도를 나타내는 표기법
(함수의 입력값과, 입력값이 커짐에 따라 변하는 함수의 실행시간 사이에 존재하는 관계를 묘사)


빅오에 대해 다룰때 있을 수 있는 가장 안좋은 경우의 수(worst case)
-> 실행시간의 최대값을 다루는 것


1. 상수는 무시한다.(1로 처리한다)
2. 최대차항을 제외하고 다 무시한다 

O(1) < O(log N) < O(N) < O(NLogN) < O(N^2) < O (N^3) << O (2^N) < O( N!)



# 공간 복잡도

시간 복잡도 - 실행시간을 가지고 알고리즘을 싱행하는데 얼마나 걸리는지를 다룸
입력값이 증가됨에 따라 알고리즘을 실행하는 시간을 분석함

공간 복잡도 - 
입력값이 증가됨에 따라 알고리즘이 차지하는 공간이 어떻게 변하는지
시간복잡도와 마찬가지로 빅오 노테이션을 사용할 수 있다.
(하지만 이젠 공간/차지하는 메모리의 크기에 대해 다룰 예정


# 공간복잡도 in JS

- 대부분의 primitive 타입(불리언, number, undefined, null)은 const 공간을 가짐
    - 값의 크기와 상관없이 동일한 크기의 공간을 차지함
- String 타입은O(n) 공간을 차지함
    - 여기서 n은 문자열의 길이
- Reference 타입도 일반적으로 O(n) 공간을 차지함
    - 배열, 객체 등등
    - 여기서 n은 배열의 길이나 객체의 키 개수

로그의 시간복잡도 
- 일부의 탐색 알고리즘
- 효율적인 정렬 알고리즘

로그의 공간복잡도
- 재귀
